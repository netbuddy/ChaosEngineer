# 混沌工程

## 1.现状

### 1.1问题

- 实验室里运行良好的系统并且经过了层层的测试、拷机、所检、X检，到了实装环境就会出现各种意想不到的问题
- 核心技术人员忙于四处救火，无法专注于技术和业务的探索和积累
- 影响了用户正常的使用，并且降低了单位的声誉

### 1.2原因

- 代码中缺乏防御式编程和故障应对预案
- 分布式系统中太多的组件，频繁的改动和革新，无数非计划中的组件交互，部件之间的强弱依赖、递归依赖、循环依赖，人类是不可能把这些内容全都放在脑中，我们缺乏对复杂系统的掌控性和可理解性，我们无法为软件系统表现出的各种行为建立一个理论预测模型，埋下隐患也就不可避免。
- 仿真数据理想、完整而富有规律；测试用例与系统的业务流程完美契合,严格按照时序同步交互；测试环境纯净、高效、稳定。实验室里的验证是平稳、渐进且逻辑性强，跳不出常规的思维框架。
- 分布式系统天生包含大量的交互、依赖点，可以出错的地方数不胜数，根据墨非定律，只要运行时间足够长，可能会出现的故障终究都会发生。例如负载的增加、硬件故障、软件缺陷、还有非法数据（有时称为脏数据）的引入。
- 生产环境中充满了混乱、无序、异常和各种噪声,数据的规模和负载上下波动，复杂分布式系统的并发性加剧了系统运行状态的随机性和不可预测性，进而引发一系列相关的竞态、死锁、野值、崩溃等设计边界之外的问题。
- 系统一直在不断更新。每天工程师和自动脚本都在通过不同的方式更新着系统，例如发布新代码，更改动态配置，添加持久化的数据，等等。
在共享状态、缓存、动态配置管理、持续交付、自动伸缩、时间敏感的代码等等的作用之下，生产环境实际上处在一个无时不在变化的状态。

### 1.3分析

- 生产环境的状态我们是无法控制的，因此必须从自身的代码入手，从正反两个方面加强质量控制
- 正的方面：开展代码审查，强化防御式编程
- 反的方面：

	- 代码只是整个系统的重要组成部分，而除了代码之外，整个系统还有很多其他方面。特别是，状态、输入、以及第三方系统导致的难易预见的系统行为。

		- 状态

			- 当我们提到状态的时候，通常我们说的是有状态服务，例如数据库服务。数据库仅仅保存一些测试设置开关的系统，与保存所有生产数据的系统，在行为上是不同的。其他一些有状态服务包括缓存服务，对象存储服务，以及可持久化的消息服务。
			- 配置数据是另一种影响系统行为的状态。无论使用静态配置文件，动态配置服务（像 etcd），还是两者的组合（像我们在 Netflix 一样），这些配置信息本身也是一种状态，而且它们可以严重影响系统行为。
			- 即使在无状态的服务中，状态仍然以内存中的数据结构的形式存在于请求之间，并因此影响到后续请求。

		- 输入

			- 系统的用户永远不会如你预期的那样与你的系统进行交互。

		- 第三方系统

			- 存在大量的你所依赖，而又不完全了解的外部服务是显而易见的。

		- 生产环境变更

	- 主动创造复杂多变、异于常态的运行环境，动态调整系统的依赖资源供给，实现或仿真各类软硬件失效情况，考察并改进系统应对未知风险的能力。
	- 传统测试只能告诉我们正在测试的系统中的某个属性的断言是真还是假。但现在我们需要更进一步发现会影响系统行为的更多未知属性。我们所感兴趣的是整个系统作为一个整体的行为
	- 每一个单一的微服务的行为都是合理的，只有在特定场景下这些行为组合起来才导致了系统预期之外的行为。

- 以己之矛，攻己之盾，查漏不缺，臻于至善
- 庖丁解牛，以无厚入有间

## 2.混沌工程

### 2.1概念

- 混沌工程是一门系统稳定性治理方法论，它提倡采用探索式的研究实验，通过实证方式主动找出系统中的脆弱环节。

### 2.2价值

- 不治已病治未病，将服务失效的困境提到最前。提前了解和控制影响范围，也比最终措手不及，应对大规模事故要好得多。
致力于在这些异常行为被触发之前，尽可能多地识别出会导致这些异常的，在系统中脆弱的，易出故障的环节。当我们识别出这些风险，我们就可以有针对性地进行加固，防范，从而避免故障发生时所带来的严重后果。
找到那些还从未发生过的事件，然后持续不断的设计实验来验证，保证这些事件即使将来出现也不会导致系统崩溃。
- 更透彻的掌握系统运行时的各种规律，理解系统行为
- 规律地进行演习，确保服务时刻具备应对整个区域中断故障的弹性，开发人员对硬件故障越来越习以为常，这种认知实际上在鼓励一种对待故障可预期性的态度，让开发人员建立起系统具备在生产环境中抵御突发事件能力的信心
- 伴随混沌工程建设而成的回滚策略和恢复系统可直接应用
- 在真实环境中观察到难以复现的问题，可以逆向找出症状的根源故障及其发生的几率，定位导致生产环境崩溃的原因。

### 2.3历史

- 混沌工程（Chaos Engineering）的概念由Netflix流媒体服务提供商提出，从出现到标准化成为一门学科，是伴随着 Netflix 过去三年多时间里同稳定性持续战斗的历程一起成长起来的，是在每一次故障之后的深度思考、抽象而成的理论和实践的结合。
- 2008 年 Netflix 开始从数据中心迁移到云上，之后就开始尝试在生产环境开展一些系统弹性的测试。过了一段时间这个实践过程才被称之为混沌工程。最早被大家熟知的是“混乱猴子”（Chaos Monkey），以其在生产环境中随机关闭服务节点而“恶名远扬”。进化成为“混乱金刚”（Chaos Kong）之后，这些之前获得的小收益被无限扩大。规模的扩大得益于一个叫做“故障注入测试”（Fault Injection Test，FIT）的工具。我们随后确立了混沌工程的若干原则，用以将这个实践规范的学科化 ，同时我们推出了混沌工程自动化平台，能够在微服务体系架构上，24*7 不间断地自动运行混沌工程实验。

### 2.4流程

- 0）建立假设

	- 思考一下当你向系统注入不同类型的事件时，稳定状态行为会发生什么变化？你期待系统如何表现？稳定状态会被破坏还是保持不变？破坏的程度和影响范围有多大？
	- 一般先提出正向的假设：系统注入的事件不会导致系统行为偏离稳定状态。
	- 在决定引入哪些事件时，我们应当估算这些事件发生的频率和影响范围，然后权衡引入他们的成本和复杂度。

- 1）设计实验

	- 将系统正常运行时的状态定义为系统的“稳定状态”，通过一个模型，基于所期望的业务指标和系统指标，来描述系统的稳定状态。
	- 故障的影响范围和隔离范围被称为故障的故障域。

- 2）执行实验、发现脆弱环节

	- 确认稳定状态

- 3）改进
- 4）验证
- 5）真实情况记录、反馈

### 2.5特点

- 伸缩性

	- 可以在不同的尺度上模拟故障，简单如在 STG 环境的某个实例上运行 kill -9 来模拟一个服务节点的突然宕机，也可以复杂到在线上挑选一小部分（但足够代表性）的流量，按一定规则或频率自动运行一系列实验。
通过递进的方式不断增加对系统的信心

- 建设性

	- 混沌一词让我们想起混乱、随机性和无序。然而，这不意味着混沌工程的实施也是随机和随意的，也不意味着混沌工程师的工作就是简单地引发混乱。
	- 混沌工程并不是简单地破坏系统、中断服务，而是让复杂系统中根深蒂固的混乱和不稳定性浮出表面，让我们可以更全面地理解这些系统性固有现象，从而在分布式系统中实现更好的工程设计，不断提高系统弹性。

- 科学性

	- 我们把混沌工程视为一种学科，一种实验学科。

- 实验性

	- 我们无法为软件系统表现出的各种行为建立一个预测模型，例如推导出一次网络延迟骤升会给系统带来什么影响。因为我们缺乏这样的理论预测模型，所以就不得不通过经验方法来理解，在各种不同情况下系统会如何表现。我们通过在系统上运行各种各样的实验，尝试给系统制造各种麻烦，看它会发生什么状况，通过实验来揭示系统的行为。

- 安全性

	- 最小化“爆炸半径”，隔离故障域，防止多个具有级联关系的故障同时出现，使得无法聚焦于关注点

### 2.6方式

- 故障注入

	- 网络故障

		- 断开网络-超时
		- 流量绕动
		- 拜占庭问题

	- IO故障

		- 磁盘
		- 文件读写

	- 数据库故障
	- 应用故障

		- 代码插桩，让函数抛出各种异常

	- 配置故障

		- 修改配置信息

- 流量激增
- 资源竞争

	- 人为占用cpu、内存负荷

- 状态同步

	- 时间不同步

### 2.7前提

- 日志系统
- 监控系统
- 自动执行系统

	- 持续验证。手动执行一次性的实验是非常好的第一步。当我们想出寻找故障空间的新方法时，我们经常从手动的方法开始，小心谨慎地处理每一件事以期建立对实验和对系统的信心。手工执行有利于：1）正确创建实验 2）确保实验有最小的“爆炸半径”。当我们成功执行了实验之后，下一步就是自动化这个实验以让其持续运行。

- 恢复系统

### 2.8发展

- 容器化

	- 具备更加细粒度和强隔离性的控制性。通过在 Docker 的宿主机网络管理中创建各种异常场景，来影响在 Docker 容器中运行的应用。这个工具的一些功能包括：在容器间创建任意分区、容器数据丢包，容器网络延迟注入，以及在故障注入时便捷的系统监控能力。

- 智能化

	- 导致系统波动的原因空间是非常巨大的，我们不可能有足够的时间和资源穷举所有可能导致问题的事件及其组合。

*XMind - Trial Version*